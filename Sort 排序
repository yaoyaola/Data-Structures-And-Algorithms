排序就是将一组对象按照某种逻辑顺序重新排列的过程。排序在商业数据处理和现代科学计算中有着重要地位。

一.选择排序
描述：
1.找到数组中最小的那个元素。
2.将它和数组中的第一个元素交换位置。
3.从剩下的元素中，找出最小的元素，将它和数组中第二个元素交换位置，如此往复，直到排序完成。

特点：
1.运行时间和输入无关：为了找出最小元素而扫描一遍数组并不能为下一次扫描提供什么信息。（不管有序无序，扫描次数固定）
2.数据移动是最少的：每次交换都会改变两个元素的值，交换次数和数组大小是线性关系N.

Java实现：
public static void selectSort(int[] a){
	for(int i=0;i<a.length;i++){
		int min = i;
		for(int j = i+1;j<a.length;j++){
			if(a[j]<a[min]){
				int temp = a[min];
				a[min] = a[j];
				a[j] = temp;
				min = j;
			}
		}

	}
	for(int k = 0;k<a.length;k++){
		System.out.print(a[k]+",");
	}
		
}


二.插入排序
将元素放在适当的位置上，这个位置后面所有的元素都往后移动一位，就是插入排序。
描述：
对于0到N-1之间的每个i，将b[i]与 b[i-1]到b[0]之间比它小的依次有序的交换
在索引i变化过程中，它的左侧都是有序的，当i到达右侧，排序完成。

Java实现：
public static void insertSort(int[] b){
	for(int i=1;i<b.length;i++){
		//将a[i]插入到a[i-1],a[i-2]...中去
		for(int j = i;j>0;j--){
			if(b[j]<b[j-1]){
				int temp = b[j];
				b[j] = b[j-1];
				b[j-1] = temp;
			}
		}
	}
	for(int k = 0; k<b.length;k++){
		System.out.println(b[k]);
	}	
}

如何提高插入排序的速度：在循环内部将较大的元素都向右移动而不总是交换两个元素，这样访问数组的次数就能减半。
try：
public static void newInsertSort(int[] a){
	for(int i = 1;i<a.length;i++){
		int temp = a[i];
		int position = i;
		for(int j = i;j>0;j--){
			if(a[j]>temp){
				a[j+1] = a[j];
				position = j;
			}
		}
		a[position] = temp;

	}
	for(int k=0;k<a.length;k++){
		System.out.println(a[k]);
	}
}


三.希尔排序
对于大规模乱序数组，插入排序就会很慢，因为它只会交换相邻元素，因此元素只能一点点地从一端移动到另一端。
希尔排序的思想是 使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。
一个h有序数组就是h个互相独立的有序数组编织在一起形成的数组。
在进行排序的过程中，如果h很大，就需要将需要移动的元素转移到很远的地方，为实现更小的h有序创造方便。

实现希尔排序的一种方法是，对于每个h，用插入排序将h个子数组独立地排序。
希尔排序高效的原因在于它权衡了子数组的规模和有序性，排序之初，每个子数组都很小，排序之后每个子数组都是部分有序的，这两种情况都适合插入排序。
子数组部分有序的程度取决于递增序列的选择。透彻理解希尔排序的性能至今仍是一项挑战。

java实现：
public static void shellSort2(int[] arr){
	// i表示希尔排序中的第n/2+1个元素（或者n/4+1）
        // j表示希尔排序中从0到n/2的元素（n/4）
        // r表示希尔排序中n/2+1或者n/4+1的值
        int i, j, r, tmp;
        // 划组排序
        for(r = arr.length / 2; r >= 1; r = r / 2) {
            for(i = r; i < arr.length; i++) {
                tmp = arr[i];
                j = i - r;//记录当前比较对象的位置
                // 一轮排序-插入排序
                while(j >= 0 && tmp < arr[j]) {
                    arr[j+r] = arr[j];
                    j -= r;
                }
                arr[j+r] = tmp;
            }
        }
        for(int k=0;k<arr.length;k++){
			System.out.println(arr[k]);
	}
}

再描述：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，
待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），
效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。
为什么在while中j要减去步长r？如果发生交换，则tmp要放在与之交换的位置上，如果没有发生交换，则tmp扔放在原位置上。


三.冒泡排序
描述：
临近的数字两两进行比较,按照从小到大或者从大到小的顺序进行交换,
这样一趟过去后,最大或最小的数字被交换到了最后一位,
然后再从头开始进行两两比较交换,直到倒数第二位时结束,
往复直到排序结束

java 描述；
public static void BubbleSort(int[] a){
	for(int i=0;i<a.length;i++){
		for(int j=a.length-i-1;j>0;j--){
			if(a[j]<a[j-1]){
				int temp = a[j];
				a[j] = a[j-1];
				a[j-1] = temp;
			}
		}
	}
	for(int k=0;k<a.length;k++){
		System.out.print(+a[k]+",");
	}
}

四.快速排序
既不浪费空间又可以快一点的排序算法就是快速排序
快速排序是冒泡排序的改进版，也是最好的一种内排序
快速排序采用的思想是分治思想，
快速排序算法的核心算法是分区操作，即如何调整基准的位置以及调整返回基准的最终位置以便分治递归。

快速排序的时间主要耗费在划分操作上，对长度为k的区间进行划分，共需k-1次关键字的比较。

描述：
1.在待排序的元素任取一个元素作为基准(通常选第一个元素，但最好的选择方法是从待排序元素中随机选取一个作为基准)，称为基准元素；
2.将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边；
3.对左右两个分区重复以上步骤直到所有元素都是有序的。

Java 描述：

public static void quickSort(int arr[],int _left,int _right){
	int left = _left;
	int right = _right;
	int temp = 0;
	if(left <= right){   //待排序的元素至少有两个的情况
	    temp = arr[left];  //待排序的第一个元素作为基准元素
	    while(left != right){   //从左右两边交替扫描，直到left = right

		while(right > left && arr[right] >= temp){
			right --;        //从右往左扫描，找到第一个比基准元素小的元素
		}
		  arr[left] = arr[right];  //找到这种元素arr[right]后与arr[left]交换

		while(left < right && arr[left] <= temp){
			left ++;         //从左往右扫描，找到第一个比基准元素大的元素
		}
		  arr[right] = arr[left];  //找到这种元素arr[left]后，与arr[right]交换

	    }
	    arr[right] = temp;    //基准元素归位
	    quickSort(arr,_left,left-1);  //对基准元素左边的元素进行递归排序
	    quickSort(arr, right+1,_right);  //对基准元素右边的进行递归排序
	}        
}

